# -*- coding: utf-8 -*-
"""kalaman_filtre.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mWlpQt5Dy9TYR4by2v6mNZDN3IKaCRp4
"""

import cv2
import numpy as np
import json
from google.colab.patches import cv2_imshow


class KalmanFilterColorDetector:
    def __init__(self):
        self.kalman = cv2.KalmanFilter(4, 2)  # 4 states (x, y, vx, vy), 2 measurements (H, S)
        self.kalman.measurementMatrix = np.array([[1, 0, 0, 0],
                                                  [0, 1, 0, 0]], np.float32)
        self.kalman.transitionMatrix = np.array([[1, 0, 1, 0],
                                                 [0, 1, 0, 1],
                                                 [0, 0, 1, 0],
                                                 [0, 0, 0, 1]], np.float32)
        self.kalman.processNoiseCov = np.array([[1e-4, 0, 0, 0],
                                                [0, 1e-4, 0, 0],
                                                [0, 0, 1e-4, 0],
                                                [0, 0, 0, 1e-4]], np.float32)

    def detect_color(self, frame):
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, (0, 70, 50), (10, 255, 255))  # Red color range
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        if len(contours) > 0:
            contour = max(contours, key=cv2.contourArea)
            x, y, w, h = cv2.boundingRect(contour)
            center_x = x + w // 2
            center_y = y + h // 2
            measurement = np.array([[center_x], [center_y]], dtype=np.float32)

            self.kalman.correct(measurement)
            prediction = self.kalman.predict()

            color = tuple(frame[center_y, center_x])
            return int(prediction[0]), int(prediction[1]), color

        return None

    def run(self, video_path, output_json):
        cap = cv2.VideoCapture(video_path)
        frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        fps = int(cap.get(cv2.CAP_PROP_FPS))
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

        results = []

        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break

            result = {}

            # Detect color and get object position
            position = self.detect_color(frame)

            if position is not None:
                result['frame_index'] = int(cap.get(cv2.CAP_PROP_POS_FRAMES))
                result['position'] = [int(position[0]), int(position[1])]
                result['color'] = [int(c) for c in position[2]]  # Convert color to list of integer

                results.append(result)

            cv2_imshow(frame)  # Display frame using cv2_imshow
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

        cap.release()
        cv2.destroyAllWindows()

        # Save the collected information in a JSON file
        with open(output_json, 'w') as file:
            json.dump(results, file)

        print("Data saved to", output_json)


if __name__ == '__main__':
    detector = KalmanFilterColorDetector()
    detector.run('video.mp4', 'output.json')

import cv2
import numpy as np
import json
from google.colab.patches import cv2_imshow


class KalmanFilterColorDetector:
    def __init__(self):
        self.kalman = cv2.KalmanFilter(4, 2)  # 4 states (x, y, vx, vy), 2 measurements (H, S)
        self.kalman.measurementMatrix = np.array([[1, 0, 0, 0],
                                                  [0, 1, 0, 0]], np.float32)
        self.kalman.transitionMatrix = np.array([[1, 0, 1, 0],
                                                 [0, 1, 0, 1],
                                                 [0, 0, 1, 0],
                                                 [0, 0, 0, 1]], np.float32)
        self.kalman.processNoiseCov = np.array([[1e-4, 0, 0, 0],
                                                [0, 1e-4, 0, 0],
                                                [0, 0, 1e-4, 0],
                                                [0, 0, 0, 1e-4]], np.float32)

    def detect_color(self, frame):
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, (0, 70, 50), (10, 255, 255))  # Red color range
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        if len(contours) > 0:
            contour = max(contours, key=cv2.contourArea)
            x, y, w, h = cv2.boundingRect(contour)
            center_x = x + w // 2
            center_y = y + h // 2
            measurement = np.array([[center_x], [center_y]], dtype=np.float32)

            self.kalman.correct(measurement)
            prediction = self.kalman.predict()

            color = tuple(frame[center_y, center_x])
            return int(prediction[0]), int(prediction[1]), color

        return None

    def run(self, input_source, output_json):
        if input_source == 'webcam':
            cap = cv2.VideoCapture(0)
        else:
            cap = cv2.VideoCapture(input_source)

        results = []

        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break

            result = {}

            # Detect color and get object position
            position = self.detect_color(frame)

            if position is not None:
                result['position'] = [int(position[0]), int(position[1])]
                result['color'] = [int(c) for c in position[2]]  # Convert color to list of integers

                # Store other relevant information
                # ...

                results.append(result)

            cv2_imshow(frame)  # Display frame using cv2_imshow
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

        cap.release()
        cv2.destroyAllWindows()

        # Save the collected information in a JSON file
        with open(output_json, 'w') as file:
            json.dump(results, file)

        print("Data saved to", output_json)


if __name__ == '__main__':
    detector = KalmanFilterColorDetector()
    detector.run('webcam', 'output.json')

import cv2
import numpy as np
import json

class KalmanFilterColorDetector:
    def __init__(self):
        self.kalman = cv2.KalmanFilter(4, 2)  # 4 states (x, y, vx, vy), 2 measurements (H, S)
        self.kalman.measurementMatrix = np.array([[1, 0, 0, 0],
                                                  [0, 1, 0, 0]], np.float32)
        self.kalman.transitionMatrix = np.array([[1, 0, 1, 0],
                                                 [0, 1, 0, 1],
                                                 [0, 0, 1, 0],
                                                 [0, 0, 0, 1]], np.float32)
        self.kalman.processNoiseCov = np.array([[1e-4, 0, 0, 0],
                                                [0, 1e-4, 0, 0],
                                                [0, 0, 1e-4, 0],
                                                [0, 0, 0, 1e-4]], np.float32)

    def detect_color(self, frame):
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, (0, 70, 50), (10, 255, 255))  # Red color range
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        if len(contours) > 0:
            contour = max(contours, key=cv2.contourArea)
            x, y, w, h = cv2.boundingRect(contour)
            center_x = x + w // 2
            center_y = y + h // 2
            measurement = np.array([[center_x], [center_y]], dtype=np.float32)

            self.kalman.correct(measurement)
            prediction = self.kalman.predict()

            color = tuple(frame[center_y, center_x])
            return int(prediction[0]), int(prediction[1]), color

        return None

    def process_image(self, image_path):
        frame = cv2.imread(image_path)

        if frame is None:
            print("Failed to load the image:", image_path)
            return

        result = {}

        # Detect color and get object position
        position = self.detect_color(frame)

        if position is not None:
            result['position'] = [int(position[0]), int(position[1])]
            result['color'] = [int(c) for c in position[2]]  # Convert color to list of integers

            # Store other relevant information
            # ...

        return result

    def process_images(self, image_paths):
        results = []

        for image_path in image_paths:
            result = self.process_image(image_path)
            if result is not None:
                results.append(result)

        return results

    def save_results_to_json(self, results, output_json):
        with open(output_json, 'w') as file:
            json.dump(results, file)

        print("Data saved to", output_json)


if __name__ == '__main__':
    detector = KalmanFilterColorDetector()

    # Specify the paths of the input images
    image_paths = ['image1.jpg', 'image2.jpg', 'image3.jpg']

    # Process the images and collect the results
    results = detector.process_images(image_paths)

    # Save the results to a JSON file
    detector.save_results_to_json(results, 'output.json')